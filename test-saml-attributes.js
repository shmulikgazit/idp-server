/**
 * SAML AttributeStatement Test
 * 
 * This test validates that SAML responses generated by samlify include
 * the required AttributeStatement section with loginName and siteId attributes
 * for LivePerson Denver SAML SSO authentication.
 * 
 * Key learnings from this test:
 * 1. customTagReplacement must be a FUNCTION, not an object
 * 2. Function signature: createLoginResponse(sp, requestInfo, binding, user, customTagReplacement, encryptThenSign, relayState)
 * 3. customTagReplacement function must return {id, context} object
 * 4. All template variables {VariableName} must be replaced in the template
 * 
 * Usage: node test-saml-attributes.js
 */

const saml = require('samlify');
const fs = require('fs');
const path = require('path');

console.log('ðŸ§ª === SAML Correct Approach Test ===');

async function testCorrectApproach() {
    // Load certificates
    const signingCert = fs.readFileSync(path.join(__dirname, 'certs', 'samlify-signing-cert.pem'), 'utf8');
    const signingKey = fs.readFileSync(path.join(__dirname, 'certs', 'samlify-private.pem'), 'utf8');
    
    const testLoginName = 'test.agent@example.com';
    const testSiteId = 'a41244303';
    const testDestination = 'https://test.liveperson.com/acs';
    
    console.log('ðŸ“‹ Test: Correct customTagReplacement function approach...');
    
    try {
        // Create Identity Provider with custom template
        const identityProvider = saml.IdentityProvider({
            privateKey: signingKey,
            metadata: `<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://idp.liveperson.com">
  <IDPSSODescriptor WantAuthnRequestsSigned="false" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
    <KeyDescriptor use="signing">
      <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
        <X509Data>
          <X509Certificate>${signingCert.replace(/-----BEGIN CERTIFICATE-----\s*|\s*-----END CERTIFICATE-----/g, '').replace(/\s/g, '')}</X509Certificate>
        </X509Data>
      </KeyInfo>
    </KeyDescriptor>
    <NameIDFormat>urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified</NameIDFormat>
    <SingleSignOnService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="https://idp.liveperson.com/sso"/>
  </IDPSSODescriptor>
</EntityDescriptor>`,
            loginResponseTemplate: {
                context: `<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" ID="{ID}" Version="2.0" IssueInstant="{IssueInstant}" Destination="{Destination}" InResponseTo="{InResponseTo}">
    <saml:Issuer>{Issuer}</saml:Issuer>
    <samlp:Status>
        <samlp:StatusCode Value="{StatusCode}"/>
    </samlp:Status>
    <saml:Assertion xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema" ID="{AssertionID}" Version="2.0" IssueInstant="{IssueInstant}">
        <saml:Issuer>{Issuer}</saml:Issuer>
        <saml:Subject>
            <saml:NameID Format="{NameIDFormat}">{NameID}</saml:NameID>
            <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
                <saml:SubjectConfirmationData NotOnOrAfter="{SubjectConfirmationDataNotOnOrAfter}" Recipient="{SubjectRecipient}" InResponseTo="{InResponseTo}"/>
            </saml:SubjectConfirmation>
        </saml:Subject>
        <saml:Conditions NotBefore="{ConditionsNotBefore}" NotOnOrAfter="{ConditionsNotOnOrAfter}">
            <saml:AudienceRestriction>
                <saml:Audience>{Audience}</saml:Audience>
            </saml:AudienceRestriction>
        </saml:Conditions>
        <saml:AuthnStatement AuthnInstant="{AuthnInstant}" SessionIndex="{SessionIndex}">
            <saml:AuthnContext>
                <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:Password</saml:AuthnContextClassRef>
            </saml:AuthnContext>
        </saml:AuthnStatement>
        <saml:AttributeStatement>
            <saml:Attribute Name="loginName" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
                <saml:AttributeValue xsi:type="xs:string">{LoginName}</saml:AttributeValue>
            </saml:Attribute>
            <saml:Attribute Name="siteId" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
                <saml:AttributeValue xsi:type="xs:string">{SiteId}</saml:AttributeValue>
            </saml:Attribute>
        </saml:AttributeStatement>
    </saml:Assertion>
</samlp:Response>`
            }
        });
        
        const serviceProvider = saml.ServiceProvider({
            metadata: {
                entityID: 'LEna2',
                authnRequestsSigned: false,
                wantAssertionsSigned: true,
                wantMessageSigned: false,
                nameIDFormat: ['urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified'],
                assertionConsumerService: [{
                    Binding: 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',
                    Location: testDestination
                }]
            }
        });
        
        const user = {
            nameID: testLoginName,
            nameIDFormat: 'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified',
            attributes: {
                'loginName': testLoginName,
                'siteId': testSiteId
            }
        };
        
        console.log('   Creating customTagReplacement function...');
        
        // This is the CORRECT way to use customTagReplacement - as a function!
        const customTagReplacementFunction = (template) => {
            console.log('   ðŸ”§ customTagReplacement called with template length:', template.length);
            
            // Replace all the template variables
            let processedTemplate = template
                .replace(/{ID}/g, 'response_' + Math.random().toString(36).substr(2, 9))
                .replace(/{AssertionID}/g, 'assertion_' + Math.random().toString(36).substr(2, 9))
                .replace(/{IssueInstant}/g, new Date().toISOString())
                .replace(/{Destination}/g, testDestination)
                .replace(/{Issuer}/g, 'https://idp.liveperson.com')
                .replace(/{StatusCode}/g, 'urn:oasis:names:tc:SAML:2.0:status:Success')
                .replace(/{NameIDFormat}/g, 'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified')
                .replace(/{NameID}/g, testLoginName)
                .replace(/{SubjectConfirmationDataNotOnOrAfter}/g, new Date(Date.now() + 5 * 60 * 1000).toISOString())
                .replace(/{SubjectRecipient}/g, testDestination)
                .replace(/{InResponseTo}/g, '')
                .replace(/{ConditionsNotBefore}/g, new Date().toISOString())
                .replace(/{ConditionsNotOnOrAfter}/g, new Date(Date.now() + 5 * 60 * 1000).toISOString())
                .replace(/{Audience}/g, 'LEna2')
                .replace(/{AuthnInstant}/g, new Date().toISOString())
                .replace(/{SessionIndex}/g, 'session_' + Math.random().toString(36).substr(2, 9))
                .replace(/{LoginName}/g, testLoginName)
                .replace(/{SiteId}/g, testSiteId);
            
            console.log('   âœ… Template processed, contains LoginName:', processedTemplate.includes(testLoginName));
            console.log('   âœ… Template processed, contains SiteId:', processedTemplate.includes(testSiteId));
            console.log('   âœ… Template processed, contains AttributeStatement:', processedTemplate.includes('AttributeStatement'));
            
            return {
                id: 'custom_response_id_' + Math.random().toString(36).substr(2, 9),
                context: processedTemplate
            };
        };
        
        console.log('   Calling createLoginResponse with function...');
        
        const result = await identityProvider.createLoginResponse(
            serviceProvider,
            null,
            'post',
            user,
            customTagReplacementFunction,
            false,
            null
        );
        
        console.log('âœ… SUCCESS!');
        console.log('   Result type:', typeof result);
        console.log('   Result keys:', Object.keys(result));
        
        if (result.context) {
            const samlXml = Buffer.from(result.context, 'base64').toString('utf8');
            console.log('   Contains AttributeStatement:', samlXml.includes('AttributeStatement'));
            console.log('   Contains loginName attribute:', samlXml.includes('Name="loginName"'));
            console.log('   Contains siteId attribute:', samlXml.includes('Name="siteId"'));
            console.log('   Contains loginName value:', samlXml.includes(testLoginName));
            console.log('   Contains siteId value:', samlXml.includes(testSiteId));
            console.log('   NameID populated:', samlXml.includes(`<saml:NameID`) && samlXml.includes(testLoginName));
            
            fs.writeFileSync('test-correct-approach.xml', samlXml);
            console.log('   âœ… SAML saved to test-correct-approach.xml');
            
            // Show a preview of the AttributeStatement section
            const attrMatch = samlXml.match(/<saml:AttributeStatement>[\s\S]*?<\/saml:AttributeStatement>/);
            if (attrMatch) {
                console.log('   ðŸ“‹ AttributeStatement found:');
                console.log('   ', attrMatch[0].substring(0, 200) + '...');
            }
        }
        
        return true;
        
    } catch (error) {
        console.log('âŒ FAILED:', error.message);
        console.log('   Error type:', error.constructor.name);
        console.log('   Stack:', error.stack);
        return false;
    }
}

testCorrectApproach()
    .then(success => {
        if (success) {
            console.log('\nðŸŽ‰ Test completed successfully!');
            console.log('This approach should work in the main server.');
        } else {
            console.log('\nâŒ Test failed!');
        }
        process.exit(success ? 0 : 1);
    })
    .catch(error => {
        console.log('\nðŸ’¥ Test crashed:', error.message);
        process.exit(1);
    }); 